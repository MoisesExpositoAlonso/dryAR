---
title: Data cleaning and merging of rosette areas from image analysis results
author: "Moises Exposito-Alonso (moisesexpositoalonso@gmail.com)"
date: '`r Sys.Date()`'
output:
  html_document: default
  #pdf_document: default
  #html_notebook: default
---

####################################################################################

## Packages set up

```{r setup, include=F}
devtools::load_all(".")
setup()

wannaoverwrite=F
# wannaoverwrite=T

```


<!-- ## This scripts is meant to read and clean the  -->
<!-- ![Example image of germinating plants and red flags of those unsuccessful pots](../figs/P1030542.JPG) -->

# DATA READING
## Read the green pixels from image analysis

```{r load packages}
set_project_dir('field')

# ## read harvesting info
# tuev <- make_data_vegetative(location="tuebingen") #### THIS CAN ONLY BE DONE IN THE CLUSTER
# madv <- make_data_vegetative(location="madrid")
# veggyraw<-rbind(madv,tuev)
# # save as package database
# devtools::use_data(veggyraw,overwrite = F)
# write.tsv(veggyraw,file = 'data-raw/veggyraw')

data(veggyraw)
veggy=veggyraw

head(veggy)
tail(veggy)
dim(veggy)

# merge

data("genoreps")
head(genoreps)

veggy= merge(veggy,genoreps, by=c('qp','pos','site'),all.y=T)   ### NOTE ALSO
## THAT CAN BE SEVERAL PICTURES FOR A SINGLE POT!
head(veggy)

# correct two folders with a non-standard name
veggy$folder=gsub(veggy$folder,pattern = '2015_12_09y10', replacement = '2015_12_09',fixed=T) # to homogenize
veggy$folder=gsub(veggy$folder,pattern = '2015_11_17_incompleto', replacement = '2015_11_17',fixed = T) # to homogenize

# remove image information
veggy= veggy %>% mutate( pathimage= paste(pathimage,folder,image,sep='/') ) %>%
                mutate(day=as.Date(folder,format= "%Y_%m_%d")) %>%
                select(-folder, -image)
head(veggy)

```


# CONSENSUS OF DUPLICATES
## Verify replicability
```{r find duplicated pots, eval=F}
set_project_dir('field')

## check duplicated image pots
veggy=mutate(veggy, indexrep=paste(site,qp,pos,day,sep='_'))

## Number of pots used for replicability analysis
dim(veggy[duplicated(veggy$indexrep),]) # There are 790 in total from both experiments
unique(veggy[duplicated(veggy$indexrep),]$day)
unique(veggy[duplicated(veggy$indexrep),]$qp)


## Run the test for replicability
library(MCMCglmm)
lmm=MCMCglmm(data=veggy[duplicated(veggy$indexrep),], countgreen ~1, random = ~ indexrep, family = 'poisson',verbose=F)
print ( h2MCMC(lmm,randomname = 'indexrep') )

```


## Clean data by removing duplicate records from duplicated images
```{r clean data by averaging duplicated pots}
set_project_dir('field')

## Produce cleaner data than veggyraw
## Since there are duplicates but the replicability is >99%, generate average of
## counts for two pots of the same identity (can be due to two pictures per
## tray/day). Necessary for merge with master dataset later

veggy <- veggy %>%
  mutate( indexrep=paste(site,qp,pos,day,sep='_')) %>%
          group_by(indexrep) %>% summarise(site=unique(site),
                                               qp=unique(qp),
                                               pos=unique(pos),
                                               trayid=unique(trayid),
                                               rep=unique(rep),
                                               indpop=unique(indpop),
                                               water=unique(water),
                                               id=unique(id),
                                               day=unique(day),
                                               pathimage=head(unique(pathimage),n=1),
                                               countgreen=mean(countgreen),
                                               countred=mean(countred)
                                           )
veggy %>% head()
veggy %>% tail()

dim(veggy)

veggy= veggy %>% mutate( potindex=paste(site,qp,pos,id,sep="_")) %>% select(-indexrep)
veggy %>% head()
veggy %>% tail()

if(wannaoverwrite==T) devtools::use_data(veggy,overwrite = T)


```
This is not run because takes some time, instead I load the data already produced


# DATA FILTERING

## Get the total number of green
```{r total count of greens}
set_project_dir()

# get total number of green counts
green=veggy %>% group_by(site,qp,pos,trayid,rep,indpop,water,id,potindex) %>%
  summarize(greensum=sum(countgreen)) %>%
  mutate(identifier=paste(sep="_",site,qp,pos))

p<-ggplot(data=green,aes(x=log10(greensum)),fill='black' )+geom_histogram() + labs(x='log 10 (# green pixels)') 
p

```


## Removing unsuccessful pots
```{r count red and green pixels}
set_project_dir()

########################################################################################################################
##### == >  RED FLAG
# quantile(log10(veggy$countred+1),probs = seq(0,1,0.01))
# whichred= log10(veggy$countred+1) > 1.4
# table(whichred)
# length(whichred)
# nrow(veggy)
# veggy<-veggy %>% mutate(isred=whichred)
# 
# table(veggy$isred)
# lapply(veggy,veggy$potindex,FUN = function      (x) table(x$isred==TRUE))
# 
# 
# dim(veggy)
# redflags <- veggy%>%
#   group_by(potindex) %>% summarize(redflag=table(isred == TRUE)['TRUE']>3) %>% filter(redflag==TRUE)
#   # group_by(potindex) %>% summarize(redflag=any(isred==TRUE)) %>% filter(redflag==TRUE) # i think this is picking many false positives
# dim(redflags)
# unique(redflags$potindex) %>% length()
# 
# redflags <- veggy%>%
#   group_by(potindex) %>% summarize(redflag=table(isred == TRUE)['TRUE']) 
#   # group_by(potindex) %>% summarize(redflag=any(isred==TRUE)) %>% filter(redflag==TRUE) # i think this is picking many false positives
# dim(redflags)
# 
# hist(redflags$redflag)
####  this method was too sensitive. I came back to the previous one of cumulative sum

# Cumulative sum
red=veggy %>% 
  # group_by(site,qp,pos,trayid,rep,indpop,water,id) %>% 
  group_by(potindex) %>% 
  summarize(redsum=sum(countred)) 

p<-ggplot(data=red,aes(x=log10(redsum+1)),fill='black' )+geom_histogram(binwidth = 0.1) + labs(x='log 10 (# red pixels +1)') 
p


# Calculate variance across groups by establishing different threshold values
## By calculating F statistic, we calculate the variance between two groups of pots 
## whose pixels are counted. For that several thresholds are tried, the one that 
## separates better the two distribution is the one that will be used

fvals<-sapply(seq(1e4,1e6,by=1000),function(x){
    summary(aov(red$redsum ~ red$redsum >x))[[1]][["F value"]][1]
})
foundthreshold= seq(1e4,1e6,by=1000)[which(fvals==max(fvals,na.rm=T))] # =152000
print(foundthreshold)
print(log10(foundthreshold+1))

# plot over the pixel distribution and draw the line
p<-p+geom_vline(xintercept =  log10(foundthreshold+1), color='red')
p
save_plot(filename="figs/Figure_redcount_histogram.pdf",plot = p, base_width = 5,base_height = 4)

# plot the F values
qplot(y=fvals ,x= seq(1e4,1e6,by=1000)) + labs(y='F value', x='Threshold of red pixels separating good and bad pots') + geom_vline(xintercept = foundthreshold,color='red')+geom_hline(yintercept = 0)

# generate a bad flag column
table(red$redsum > foundthreshold)
redflag = red %>% filter(redsum > foundthreshold) %>% select(potindex)

########################################################################################################################
##### == >  GREEN FLAG

greenflag <- green%>% mutate(isnotgreen = greensum<10) %>%
  group_by(potindex) %>% summarize(greenflag=any(isnotgreen==TRUE)) %>% filter(greenflag==TRUE)

dim(greenflag)
unique(greenflag$potindex) %>% length()

# select those post that do not have every a red flag or green flag (no pixel)
veggyclean <- veggy %>%
  # do the filtering of red flags
    filter( !(potindex %in% redflag$potindex)) %>% # 
  # filtering at least those pots that never had any green pixel
    filter( !(potindex %in% greenflag$potindex))  # 
dim(veggyclean)

# hist(log10(veggy$countred+1))
# hist(log10(veggyclean$countred+1),add=T,col='black') # proof of concept that there are no pots with non zero

if(wannaoverwrite==T) devtools::use_data(veggyclean,overwrite = T)

```

## Model all trajectories as sigmoidal functions

```{r model all trajectories as sigmoidal functio)ns,eval=F}
set_project_dir()

dim(veggyclean)
head(veggyclean)

veg<-  veggyclean %>%
# select early positions
  mutate(starting=startday(site)) %>% # add the start day of the experiment ina per row basis for later calculations
  mutate(daycount= fn(day - as.Date(starting) ) )%>% #  trick to filter the 40 first dates depending on experiment
  # filter(daycount <60) %>% # 40 days because we started the thinning like 1 month after they started germination, probably would be better to do it in a per pot basis.

  group_by(site,qp,pos,trayid,rep,indpop,water,id,potindex) %>% # group observations by pot to analyse each time series

# calculate several trajectory informations
  
  summarize(
            ss.a=fitsigmoid(countgreen,daycount,parameter='a'),
            ss.b=fitsigmoid(countgreen,daycount,parameter='b'),
            ss.c=fitsigmoid(countgreen,daycount,parameter='c'),
            spline1=fitspline(y=countgreen,x=daycount),
            green1=firstgreen(y=countgreen,x=daycount),  # first green pixels is kind of arbitrary
            lin0=fitlinear(countgreen,daycount,'significance')  # Probably the regression one is not so nice.
            # meangreen=mean(countgreen)
            )


## Get the merge with total counts of red and green

veg=veg %>%
  full_join(.,red,by=c('site','qp','pos','trayid','rep','indpop','water','id')) %>%
  full_join(.,green,by=c('site','qp','pos','trayid','rep','indpop','water','id', 'potindex'))
dim(veg)

ggplot(veg) + 
  geom_hex(aes(y=greensum, x=redsum))

veg %>% dim()
veg %>% head()
veg %>% tail()

table(is.na(veg$spline1))
table(is.na(veg$green1))
table(veg$ss.a=='NA')
table(is.na(veg$lin0))


if(wannaoverwrite==T) devtools::use_data(veg,overwrite = T)


```
